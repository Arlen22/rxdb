"use strict";(self.webpackChunkrxdb=self.webpackChunkrxdb||[]).push([[8196],{4228:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>a,default:()=>h,frontMatter:()=>o,metadata:()=>s,toc:()=>l});var i=t(5893),r=t(1151);const o={title:"WebRTC Replication",slug:"replication-webrtc.html"},a="Peer-to-Peer (P2P) WebRTC Replication with the RxDB JavaScript Database",s={id:"replication-webrtc",title:"WebRTC Replication",description:"In the world of web and mobile development, data synchronization between clients and servers has always been a critical aspect of building real-time JavaScript applications.",source:"@site/docs/replication-webrtc.md",sourceDirName:".",slug:"/replication-webrtc.html",permalink:"/replication-webrtc.html",draft:!1,unlisted:!1,editUrl:"https://github.com/pubkey/rxdb/tree/main/docs-src/docs/replication-webrtc.md",tags:[],version:"current",frontMatter:{title:"WebRTC Replication",slug:"replication-webrtc.html"},sidebar:"tutorialSidebar",previous:{title:"CouchDB Replication",permalink:"/replication-couchdb.html"},next:{title:"Firestore Replication",permalink:"/replication-firestore.html"}},c={},l=[{value:"Understanding P2P Replication",id:"understanding-p2p-replication",level:2},{value:"Using the RxDB WebRTC Replication Plugin",id:"using-the-rxdb-webrtc-replication-plugin",level:2},{value:"Live replications",id:"live-replications",level:2},{value:"Signaling Server",id:"signaling-server",level:2},{value:"Conflict detection in WebRTC replication",id:"conflict-detection-in-webrtc-replication",level:2},{value:"Storing replicated data encrypted on client device",id:"storing-replicated-data-encrypted-on-client-device",level:2}];function d(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.a)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.h1,{id:"peer-to-peer-p2p-webrtc-replication-with-the-rxdb-javascript-database",children:"Peer-to-Peer (P2P) WebRTC Replication with the RxDB JavaScript Database"}),"\n",(0,i.jsxs)(n.p,{children:["In the world of web and mobile development, data synchronization between clients and servers has always been a critical aspect of building real-time JavaScript applications.\nTraditionally, the synchronization process relies on ",(0,i.jsx)(n.strong,{children:"centralized servers"})," to manage and distribute data. However, Peer-to-Peer (P2P) replication with ",(0,i.jsx)(n.a,{href:"https://developer.mozilla.org/en-US/docs/Web/API/WebRTC_API",children:"WebRTC"})," is changing the game by allowing data to flow ",(0,i.jsx)(n.strong,{children:"directly between clients"}),", eliminating the need for a central server."]}),"\n",(0,i.jsxs)(n.p,{children:["With the ",(0,i.jsx)(n.strong,{children:"RxDB WebRTC replication plugin"})," you can replicate the database state between your clients devices fully peer2peer over WebRTC.\nThere is no need for a centralized server to store any of the users data like in a ",(0,i.jsx)(n.strong,{children:"master-slave"})," replication.\nOnly a WebRTC signaling server is required to initially exchange the connection data between clients so that they can establish a WebRTC connection.\nThe replication itself then runs with the ",(0,i.jsx)(n.a,{href:"/replication.html",children:"RxDB replication protocol"}),". Because RxDB is a NoSQL database and because of the simplicity of its replication protocol, setting up a robust P2P replication is way easier compared to SQL server- or client databases."]}),"\n",(0,i.jsx)(n.h2,{id:"understanding-p2p-replication",children:"Understanding P2P Replication"}),"\n",(0,i.jsx)(n.p,{children:"P2P replication is a paradigm shift in data synchronization. Instead of relying on a central server to manage data transfers between clients, it leverages the power of direct peer-to-peer connections. This approach offers several advantages:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Reduced Latency:"})," With no intermediary server, data can move directly between clients, significantly reducing latency and improving real-time interactions."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Improved Scalability:"})," P2P networks can easily scale as more clients join, without putting additional load on a central server."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Enhanced Privacy:"})," Data remains within the client devices, reducing privacy concerns associated with centralized data storage."]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"using-the-rxdb-webrtc-replication-plugin",children:"Using the RxDB WebRTC Replication Plugin"}),"\n",(0,i.jsxs)(n.p,{children:["Before you use this plugin, make sure that you understand how ",(0,i.jsx)(n.a,{href:"https://developer.mozilla.org/en-US/docs/Web/API/WebRTC_API",children:"WebRTC works"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:["First you have to add the plugin, then you can call ",(0,i.jsx)(n.code,{children:"RxCollection.syncWebRTC()"})," to start the replication.\nAs options you have to provide a ",(0,i.jsx)(n.code,{children:"topic"})," and a connection handler function that implements the ",(0,i.jsx)(n.code,{children:"P2PConnectionHandlerCreator"})," interface. As default you should start with the ",(0,i.jsx)(n.code,{children:"getConnectionHandlerSimplePeer"})," method which uses the ",(0,i.jsx)(n.a,{href:"https://github.com/feross/simple-peer",children:"simple-peer"})," library."]}),"\n",(0,i.jsxs)(n.p,{children:["In difference to the other replication plugins, the WebRTC replication returns a ",(0,i.jsx)(n.code,{children:"replicationPool"})," instead of a single ",(0,i.jsx)(n.code,{children:"RxReplicationState"}),". The ",(0,i.jsx)(n.code,{children:"replicationPool"})," contains all replication states of the connected peers in the P2P network."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:"import {\n    replicateWebRTC,\n    getConnectionHandlerSimplePeer\n} from 'rxdb/plugins/replication-webrtc';\n\n\nconst replicationPool = await replicateWebRTC(\n    {\n        collection: myRxCollection,\n        // The topic is like a 'room-name'. All clients with the same topic\n        // will replicate with each other. In most cases you want to use\n        // a different topic string per user.\n        topic: 'my-users-pool',\n        /**\n         * You need a collection handler to be able to create WebRTC connections.\n         * Here we use the simple peer handler which uses the 'simple-peer' npm library.\n         * To learn how to create a custom connection handler, read the source code,\n         * it is pretty simple.\n         */\n        connectionHandlerCreator: getConnectionHandlerSimplePeer(\n            'wss://example.com:8080',\n            // only in Node.js, we need the wrtc library\n            // because Node.js does not contain the WebRTC API.\n            require('wrtc')\n        ),\n        pull: {},\n        push: {}\n    }\n);\nreplicationPool.error$.subscribe(err => { /* ... */ });\nreplicationPool.cancel();\n\n"})}),"\n",(0,i.jsx)(n.h2,{id:"live-replications",children:"Live replications"}),"\n",(0,i.jsxs)(n.p,{children:["The WebRTC replication is ",(0,i.jsx)(n.strong,{children:"always live"})," because there can not be a one-time sync when it is always possible to have new Peers that join the connection pool. Therefore you cannot set the ",(0,i.jsx)(n.code,{children:"live: false"})," option like in the other replication plugins."]}),"\n",(0,i.jsx)(n.h2,{id:"signaling-server",children:"Signaling Server"}),"\n",(0,i.jsxs)(n.p,{children:["For P2P replication to work with the RxDB WebRTC Replication Plugin, a ",(0,i.jsx)(n.a,{href:"https://developer.mozilla.org/en-US/docs/Web/API/WebRTC_API/Signaling_and_video_calling",children:"signaling server"})," is required. The signaling server helps peers discover each other and establish connections."]}),"\n",(0,i.jsx)(n.p,{children:"Creating a basic signaling server is straightforward. The provided example uses 'socket.io' for WebSocket communication. However, in production, you'd want to create a more robust signaling server with authentication and additional logic to suit your application's needs."}),"\n",(0,i.jsxs)(n.p,{children:["Here is a quick example implementation of a signaling server that can be used with the connection handler from ",(0,i.jsx)(n.code,{children:"getConnectionHandlerSimplePeer()"}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:"export async function startSignalingServer(port: number): Promise<string> {\n    const server = require('http').createServer();\n    const io = require('socket.io')(server);\n    const socketByPeerId = new Map();\n    const socketsByRoom = new Map();\n    io.on('connection', function (socket: any) {\n        socket.on('signal', (message: any) => {\n            socketByPeerId.get(message.to).emit('signal', message);\n        });\n        socket.on('join', (message: any) => {\n            if (!socketsByRoom.has(message.room)) {\n                console.log('START NEW ROOM: ' + message.room);\n                socketsByRoom.set(message.room, []);\n            }\n            socketsByRoom.get(message.room).push({\n                socket,\n                peerId: message.peerId\n            });\n            socketByPeerId.set(message.peerId, socket);\n            const roomPeerIds = socketsByRoom.get(message.room).map((row: any) => row.peerId);\n            socketsByRoom.get(message.room).forEach((row: any) => {\n                row.socket.emit('joined', roomPeerIds);\n            });\n        });\n    });\n    return new Promise(res => {\n        server.listen(port, () => {\n            res('ws://localhost:' + port);\n        });\n    });\n}\n"})}),"\n",(0,i.jsx)(n.h2,{id:"conflict-detection-in-webrtc-replication",children:"Conflict detection in WebRTC replication"}),"\n",(0,i.jsxs)(n.p,{children:["RxDB's conflict handling works by detecting and resolving conflicts that may arise when multiple clients in a decentralized database system attempt to modify the same data concurrently.\nA ",(0,i.jsx)(n.strong,{children:"custom conflict handler"})," can be set up, which is a plain JavaScript function. The conflict handler is run on each replicated document write and resolves the conflict if required. ",(0,i.jsx)(n.a,{href:"https://rxdb.info/transactions-conflicts-revisions.html",children:"Find out more about RxDB conflict handling here"})]}),"\n",(0,i.jsx)(n.h2,{id:"storing-replicated-data-encrypted-on-client-device",children:"Storing replicated data encrypted on client device"}),"\n",(0,i.jsxs)(n.p,{children:["Storing replicated data encrypted on client devices using the RxDB Encryption Plugin is a pivotal step towards bolstering ",(0,i.jsx)(n.strong,{children:"data security"})," and ",(0,i.jsx)(n.strong,{children:"user privacy"}),".\nThe WebRTC replication plugin seamlessly integrates with the ",(0,i.jsx)(n.a,{href:"/encryption.html",children:"RxDB encryption plugins"}),", providing a robust solution for encrypting sensitive information before it's stored locally. By doing so, it ensures that even if unauthorized access to the device occurs, the data remains protected and unintelligible without the encryption key (or password). This approach is particularly vital in scenarios where user-generated content or confidential data is replicated across devices, as it empowers users with control over their own data while adhering to stringent security standards. ",(0,i.jsx)(n.a,{href:"/encryption.html",children:"Read more about the encryption plugins here"}),"."]})]})}function h(e={}){const{wrapper:n}={...(0,r.a)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},1151:(e,n,t)=>{t.d(n,{Z:()=>s,a:()=>a});var i=t(7294);const r={},o=i.createContext(r);function a(e){const n=i.useContext(o);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:a(e.components),i.createElement(o.Provider,{value:n},e.children)}}}]);