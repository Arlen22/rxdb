{"version":3,"file":"connection-handler-simple-peer.js","names":["Subject","getFromMapOrThrow","PROMISE_RESOLVE_VOID","default","Peer","newRxError","sendMessage","ws","msg","send","JSON","stringify","getConnectionHandlerSimplePeer","serverUrl","wrtc","creator","options","socket","WebSocket","connect$","disconnect$","message$","response$","error$","peers","Map","ownPeerId","onopen","onmessage","msgEvent","parse","data","type","yourPeerId","room","topic","otherPeerIds","forEach","remotePeerId","has","newPeer","initiator","trickle","set","on","signal","senderPeerId","receiverPeerId","messageOrResponse","toString","result","next","peer","response","message","error","console","log","dir","handler","destroy","close","complete"],"sources":["../../../../src/plugins/replication-webrtc/connection-handler-simple-peer.ts"],"sourcesContent":["import { Subject } from 'rxjs';\nimport {\n    getFromMapOrThrow,\n    PROMISE_RESOLVE_VOID,\n    randomCouchString\n} from '../../plugins/utils/index.ts';\nimport type {\n    WebRTCConnectionHandler,\n    WebRTCConnectionHandlerCreator,\n    WebRTCMessage,\n    WebRTCPeer,\n    PeerWithMessage,\n    PeerWithResponse\n} from './webrtc-types.ts';\n\nimport {\n    Instance as SimplePeer,\n    default as Peer\n} from 'simple-peer';\nimport type { RxError, RxTypeError } from '../../types/index.d.ts';\nimport { newRxError } from '../../rx-error.ts';\n// import { WebSocket } from 'ws';\n\nexport type SimplePeerInitMessage = {\n    type: 'init';\n    yourPeerId: string;\n};\nexport type SimplePeerJoinMessage = {\n    type: 'join';\n    room: string;\n};\nexport type SimplePeerJoinedMessage = {\n    type: 'joined';\n    otherPeerIds: string[];\n};\nexport type SimplePeerSignalMessage = {\n    type: 'signal';\n    room: string;\n    senderPeerId: string;\n    receiverPeerId: string;\n    data: string;\n};\n\nexport type PeerMessage = SimplePeerInitMessage | SimplePeerJoinMessage | SimplePeerJoinedMessage | SimplePeerSignalMessage;\n\n\nfunction sendMessage(ws: WebSocket, msg: PeerMessage) {\n    ws.send(JSON.stringify(msg));\n}\n\n/**\n * Returns a connection handler that uses simple-peer and the signaling server.\n */\nexport function getConnectionHandlerSimplePeer(\n    serverUrl: string,\n    wrtc?: any\n): WebRTCConnectionHandlerCreator {\n    const creator: WebRTCConnectionHandlerCreator = async (options) => {\n        const socket = new WebSocket(serverUrl);\n\n        const connect$ = new Subject<WebRTCPeer>();\n        const disconnect$ = new Subject<WebRTCPeer>();\n        const message$ = new Subject<PeerWithMessage>();\n        const response$ = new Subject<PeerWithResponse>();\n        const error$ = new Subject<RxError | RxTypeError>();\n\n        const peers = new Map<string, SimplePeer>();\n\n        let ownPeerId: string;\n        socket.onopen = () => {\n            socket.onmessage = msgEvent => {\n                const msg: PeerMessage = JSON.parse(msgEvent.data);\n                switch (msg.type) {\n                    case 'init':\n                        ownPeerId = msg.yourPeerId;\n                        sendMessage(socket, {\n                            type: 'join',\n                            room: options.topic\n                        });\n                        break;\n                    case 'joined':\n                        /**\n                         * PeerId is created by the signaling server\n                         * to prevent spoofing it.\n                         */\n                        msg.otherPeerIds.forEach(remotePeerId => {\n                            if (\n                                remotePeerId === ownPeerId ||\n                                peers.has(remotePeerId)\n                            ) {\n                                return;\n                            }\n                            const newPeer: SimplePeer = new Peer({\n                                initiator: remotePeerId > ownPeerId,\n                                wrtc,\n                                trickle: true\n                            }) as any;\n                            peers.set(remotePeerId, newPeer);\n\n                            newPeer.on('signal', (signal: any) => {\n                                sendMessage(socket, {\n                                    type: 'signal',\n                                    senderPeerId: ownPeerId,\n                                    receiverPeerId: remotePeerId,\n                                    room: options.topic,\n                                    data: signal\n                                });\n                            });\n\n                            newPeer.on('data', (messageOrResponse: any) => {\n                                messageOrResponse = JSON.parse(messageOrResponse.toString());\n                                if (messageOrResponse.result) {\n                                    response$.next({\n                                        peer: newPeer as any,\n                                        response: messageOrResponse\n                                    });\n                                } else {\n                                    message$.next({\n                                        peer: newPeer as any,\n                                        message: messageOrResponse\n                                    });\n                                }\n                            });\n\n                            newPeer.on('error', (error) => {\n                                console.log('CLIENT(' + ownPeerId + ') peer got error:');\n                                console.dir(error);\n                                error$.next(newRxError('RC_WEBRTC_PEER', {\n                                    error\n                                }));\n                            });\n\n                            newPeer.on('connect', () => {\n                                connect$.next(newPeer as any);\n                            });\n\n                        });\n                        break;\n                    case 'signal':\n                        // console.log('got signal(' + peerId + ') ' + data.from + ' -> ' + data.to);\n                        const peer = getFromMapOrThrow(peers, msg.senderPeerId);\n                        peer.signal(msg.data);\n                        break;\n                }\n            }\n        };\n\n        const handler: WebRTCConnectionHandler = {\n            error$,\n            connect$,\n            disconnect$,\n            message$,\n            response$,\n            async send(peer: WebRTCPeer, message: WebRTCMessage) {\n                await (peer as any).send(JSON.stringify(message));\n            },\n            destroy() {\n                socket.close();\n                error$.complete();\n                connect$.complete();\n                disconnect$.complete();\n                message$.complete();\n                response$.complete();\n                return PROMISE_RESOLVE_VOID;\n            }\n        };\n        return handler;\n    };\n    return creator;\n}\n"],"mappings":"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"}