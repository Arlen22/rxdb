{"version":3,"file":"webrtc-types.js","names":[],"sources":["../../../../src/plugins/replication-webrtc/webrtc-types.ts"],"sourcesContent":["import { Observable, Subscription } from 'rxjs';\nimport type {\n    ReplicationOptions,\n    ReplicationPullOptions,\n    ReplicationPushOptions,\n    RxError,\n    RxReplicationHandler,\n    RxStorageDefaultCheckpoint,\n    RxTypeError,\n    StringKeys\n} from '../../types/index.d.ts';\nimport { RxReplicationState } from '../replication/index.ts';\nimport { WebsocketMessageResponseType, WebsocketMessageType } from '../replication-websocket/index.ts';\n\nexport type WebRTCPeer = {\n    id: string;\n};\nexport type WebRTCReplicationCheckpoint = RxStorageDefaultCheckpoint;\n\n\nexport type WebRTCMessage = Omit<WebsocketMessageType, 'method' | 'collection'> & {\n    method: StringKeys<RxReplicationHandler<any, any>> | 'token';\n};\nexport type WebRTCResponse = Omit<WebsocketMessageResponseType, 'collection'>;\nexport type PeerWithMessage = {\n    peer: WebRTCPeer;\n    message: WebRTCMessage;\n};\nexport type PeerWithResponse = {\n    peer: WebRTCPeer;\n    response: WebRTCResponse;\n};\n\nexport type WebRTCConnectionHandler = {\n    connect$: Observable<WebRTCPeer>;\n    disconnect$: Observable<WebRTCPeer>;\n    message$: Observable<PeerWithMessage>;\n    response$: Observable<PeerWithResponse>;\n    error$: Observable<RxError | RxTypeError>;\n    send(peer: WebRTCPeer, message: WebRTCMessage | WebRTCResponse): Promise<void>;\n    destroy(): Promise<void>;\n};\n\nexport type WebRTCConnectionHandlerCreator = (\n    opts: SyncOptionsWebRTC<any>\n) => Promise<WebRTCConnectionHandler>;\n\nexport type WebRTCSyncPushOptions<RxDocType> = Omit<\nReplicationPushOptions<RxDocType>,\n'handler'\n> & {};\n\nexport type WebRTCSyncPullOptions<RxDocType> = Omit<\nReplicationPullOptions<RxDocType, WebRTCReplicationCheckpoint>,\n'handler' | 'stream$'\n> & {};\n\nexport type SyncOptionsWebRTC<RxDocType> = Omit<\nReplicationOptions<RxDocType, WebRTCReplicationCheckpoint>,\n'pull' |\n'push' |\n'replicationIdentifier' |\n'deletedField' |\n'live' |\n'autostart' |\n'waitForLeadership'\n> & {\n    /**\n     * It will only replicate with other instances\n     * that use the same topic and\n     * are able to prove that they know the secret.\n     */\n    topic: string;\n    secret: string;\n    connectionHandlerCreator: WebRTCConnectionHandlerCreator;\n    pull?: WebRTCSyncPullOptions<RxDocType>;\n    push?: WebRTCSyncPushOptions<RxDocType>;\n};\n\nexport type RxWebRTCReplicationState<RxDocType> = RxReplicationState<RxDocType, WebRTCReplicationCheckpoint>;\n\n\nexport type WebRTCPeerState<RxDocType> = {\n    peer: WebRTCPeer;\n    // only exists when the peer was picked as master and the own client was picked as fork.\n    replicationState?: RxWebRTCReplicationState<RxDocType>;\n    // clean this up when removing the peer\n    subs: Subscription[];\n};\n"],"mappings":""}