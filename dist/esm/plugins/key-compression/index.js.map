{"version":3,"file":"index.js","names":["createCompressionTable","compressObject","decompressObject","compressedPath","DEFAULT_COMPRESSION_FLAG","createCompressedJsonSchema","compressQuery","overwritable","wrapRxStorageInstance","getPrimaryFieldOfPrimaryKey","flatCloneDocWithMeta","flatClone","getFromMapOrCreate","isMaybeReadonlyArray","prepareQuery","COMPRESSION_STATE_BY_SCHEMA","WeakMap","getCompressionStateByRxJsonSchema","schema","deepFreezeWhenDevMode","compressionSchema","primaryKey","table","compressedSchema","composedPrimary","newComposedPrimary","key","fields","map","field","separator","indexes","newIndexes","idx","subIdx","compressionState","wrappedKeyCompressionStorage","args","statics","Object","assign","storage","createStorageInstance","params","keyCompression","modifyToStorage","docData","compressDocumentData","modifyFromStorage","decompressDocumentData","childSchema","instance","wrappedInstance","queryBefore","query","bind","preparedQuery","compressedQuery","compressedPreparedQuery","attachments","_attachments"],"sources":["../../../../src/plugins/key-compression/index.ts"],"sourcesContent":["/**\n * this plugin adds the keycompression-capabilities to rxdb\n * if you don't use this, ensure that you set disableKeyCompression to false in your schema\n */\n\nimport {\n    createCompressionTable,\n    CompressionTable,\n    JsonSchema as KeyCompressionJsonSchema,\n    compressObject,\n    decompressObject,\n    compressedPath,\n    DEFAULT_COMPRESSION_FLAG,\n    createCompressedJsonSchema,\n    compressQuery\n} from 'jsonschema-key-compression';\nimport {\n    overwritable\n} from '../../overwritable.ts';\nimport { wrapRxStorageInstance } from '../../plugin-helpers.ts';\nimport { getPrimaryFieldOfPrimaryKey } from '../../rx-schema-helper.ts';\nimport { flatCloneDocWithMeta } from '../../rx-storage-helper.ts';\n\nimport type {\n    RxJsonSchema,\n    CompositePrimaryKey,\n    RxStorage,\n    RxStorageInstanceCreationParams,\n    RxDocumentData,\n    RxStorageStatics,\n    FilledMangoQuery,\n    PreparedQuery,\n    RxDocumentWriteData\n} from '../../types/index.d.ts';\nimport {\n    clone,\n    flatClone,\n    getFromMapOrCreate,\n    isMaybeReadonlyArray\n} from '../../plugins/utils/index.ts';\nimport { prepareQuery } from '../../rx-query.ts';\n\ndeclare type CompressionState = {\n    table: CompressionTable;\n    schema: RxJsonSchema<any>;\n    compressedSchema: RxJsonSchema<any>;\n};\n\n/**\n * Cache the compression table and the compressed schema\n * by the storage instance for better performance.\n */\nconst COMPRESSION_STATE_BY_SCHEMA: WeakMap<\n    RxJsonSchema<any>,\n    CompressionState\n> = new WeakMap();\n\n\nexport function getCompressionStateByRxJsonSchema(\n    schema: RxJsonSchema<any>\n): CompressionState {\n    /**\n     * Because we cache the state by the JsonSchema,\n     * it must be assured that the given schema object\n     * is never mutated.\n     */\n    overwritable.deepFreezeWhenDevMode(schema);\n\n    return getFromMapOrCreate(\n        COMPRESSION_STATE_BY_SCHEMA,\n        schema,\n        () => {\n            const compressionSchema: KeyCompressionJsonSchema = flatClone(schema) as any;\n            delete (compressionSchema as any).primaryKey;\n\n            const table = createCompressionTable(\n                compressionSchema,\n                DEFAULT_COMPRESSION_FLAG,\n                [\n                    /**\n                     * Do not compress the primary field\n                     * for easier debugging.\n                     */\n                    getPrimaryFieldOfPrimaryKey(schema.primaryKey),\n                    '_rev',\n                    '_attachments',\n                    '_deleted',\n                    '_meta'\n                ]\n            );\n\n            delete (compressionSchema as any).primaryKey;\n            const compressedSchema: RxJsonSchema<any> = createCompressedJsonSchema(\n                table,\n                compressionSchema\n            ) as RxJsonSchema<any>;\n\n            // also compress primary key\n            if (typeof schema.primaryKey !== 'string') {\n                const composedPrimary: CompositePrimaryKey<any> = schema.primaryKey;\n                const newComposedPrimary: CompositePrimaryKey<any> = {\n                    key: compressedPath(table, composedPrimary.key as string),\n                    fields: composedPrimary.fields.map(field => compressedPath(table, field as string)),\n                    separator: composedPrimary.separator\n                };\n                compressedSchema.primaryKey = newComposedPrimary;\n            } else {\n                compressedSchema.primaryKey = compressedPath(table, schema.primaryKey);\n            }\n\n            /**\n             * the key compression module does not know about indexes\n             * in the schema, so we have to also compress them here.\n             */\n            if (schema.indexes) {\n                const newIndexes = schema.indexes.map(idx => {\n                    if (isMaybeReadonlyArray(idx)) {\n                        return idx.map(subIdx => compressedPath(table, subIdx));\n                    } else {\n                        return compressedPath(table, idx);\n                    }\n                });\n                compressedSchema.indexes = newIndexes;\n            }\n\n            const compressionState = {\n                table,\n                schema,\n                compressedSchema\n            };\n            return compressionState;\n        }\n    );\n}\n\nexport function wrappedKeyCompressionStorage<Internals, InstanceCreationOptions>(\n    args: {\n        storage: RxStorage<Internals, InstanceCreationOptions>;\n    }\n): RxStorage<Internals, InstanceCreationOptions> {\n    const statics: RxStorageStatics = Object.assign(\n        {},\n        args.storage.statics,\n        {}\n    );\n\n    return Object.assign(\n        {},\n        args.storage,\n        {\n            statics,\n            async createStorageInstance<RxDocType>(\n                params: RxStorageInstanceCreationParams<RxDocType, any>\n            ) {\n                if (!params.schema.keyCompression) {\n                    return args.storage.createStorageInstance(params);\n                }\n\n                const compressionState = getCompressionStateByRxJsonSchema(params.schema);\n                function modifyToStorage(docData: RxDocumentWriteData<RxDocType>) {\n                    return compressDocumentData(compressionState, docData);\n                }\n                function modifyFromStorage(docData: RxDocumentData<any>): Promise<RxDocumentData<RxDocType>> {\n                    return decompressDocumentData(compressionState, docData);\n                }\n\n                /**\n                 * Because this wrapper resolves the key-compression,\n                 * we can set the flag to false\n                 * which allows underlying storages to detect wrong configurations\n                 * like when keyCompression is set to false but no key-compression module is used.\n                 */\n                const childSchema = flatClone(compressionState.compressedSchema);\n                childSchema.keyCompression = false;\n\n                const instance = await args.storage.createStorageInstance(\n                    Object.assign(\n                        {},\n                        params,\n                        {\n                            schema: childSchema\n                        }\n                    )\n                );\n\n                const wrappedInstance = wrapRxStorageInstance(\n                    params.schema,\n                    instance,\n                    modifyToStorage,\n                    modifyFromStorage\n                );\n\n                const queryBefore = wrappedInstance.query.bind(wrappedInstance);\n                wrappedInstance.query = async (preparedQuery: PreparedQuery<RxDocType>) => {\n                    const compressedQuery: FilledMangoQuery<RxDocType> = compressQuery(\n                        compressionState.table,\n                        preparedQuery.query as any\n                    ) as any;\n\n                    const compressedPreparedQuery = prepareQuery(\n                        compressionState.compressedSchema,\n                        compressedQuery\n                    );\n                    return queryBefore(compressedPreparedQuery);\n                }\n\n                return wrappedInstance;\n            }\n        }\n    );\n}\n\nexport function compressDocumentData(\n    compressionState: CompressionState,\n    docData: RxDocumentData<any>\n): RxDocumentData<any> {\n    /**\n     * Do not send attachments to compressObject()\n     * because it will deep clone which does not work on Blob or Buffer.\n     */\n    docData = flatCloneDocWithMeta(docData);\n    const attachments = docData._attachments;\n    delete docData._attachments;\n\n    docData = compressObject(\n        compressionState.table,\n        docData\n    );\n    docData._attachments = attachments;\n    return docData;\n}\n\nexport function decompressDocumentData(\n    compressionState: CompressionState,\n    docData: RxDocumentData<any>\n): RxDocumentData<any> {\n    return decompressObject(\n        compressionState.table,\n        docData\n    );\n}\n"],"mappings":"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"}