{"version":3,"file":"websocket-client.js","names":["replicateRxCollection","ReconnectingWebSocket","IsomorphicWebSocket","errorToPlainJson","getFromMapOrCreate","getFromMapOrThrow","randomCouchString","toArray","filter","map","Subject","firstValueFrom","BehaviorSubject","newRxError","ensureIsWebsocket","w","is","CLOSING","console","dir","Error","WEBSOCKET_BY_CACHE_KEY","Map","getWebSocket","url","databaseToken","cacheKey","has","wsClient","WebSocket","connected$","openPromise","Promise","res","onopen","next","onclose","message$","onmessage","messageObj","message","JSON","parse","data","error$","onerror","err","emitError","errors","er","direction","socket","refCount","value","removeWebSocketRef","database","token","obj","delete","complete","close","replicateWithWebsocketServer","options","socketState","collection","messages$","requestCounter","requestFlag","getRequestId","count","replicationState","replicationIdentifier","live","pull","batchSize","stream$","pipe","msg","id","name","result","handler","lastPulledCheckpoint","requestId","request","method","params","send","stringify","push","docs","subscribe","subjects","error","isConnected","reSync","streamRequest","onDestroy"],"sources":["../../../../src/plugins/replication-websocket/websocket-client.ts"],"sourcesContent":["import { replicateRxCollection, RxReplicationState } from '../replication';\nimport {\n    WebsocketClientOptions,\n    WebsocketMessageType\n} from './websocket-types';\n\nimport ReconnectingWebSocket from 'reconnecting-websocket';\nimport IsomorphicWebSocket from 'isomorphic-ws';\nimport {\n    errorToPlainJson,\n    getFromMapOrCreate,\n    getFromMapOrThrow,\n    randomCouchString,\n    toArray\n} from '../../plugins/utils';\nimport {\n    filter,\n    map,\n    Subject,\n    firstValueFrom,\n    BehaviorSubject\n} from 'rxjs';\nimport {\n    RxDatabase,\n    RxError,\n    RxReplicationWriteToMasterRow\n} from '../../types';\nimport { newRxError } from '../../rx-error';\n\nexport type WebsocketWithRefCount = {\n    url: string;\n    socket: ReconnectingWebSocket;\n    refCount: number;\n    openPromise: Promise<void>;\n    connected$: BehaviorSubject<boolean>;\n    message$: Subject<any>;\n    error$: Subject<RxError>;\n};\n\n\n/**\n * Copied and adapter from the 'reconnecting-websocket' npm module.\n * Some bundlers have problems with bundling the isomorphic-ws plugin\n * so we directly check the correctness in RxDB to ensure that we can\n * throw a helpful error.\n */\nfunction ensureIsWebsocket(w: typeof IsomorphicWebSocket) {\n    const is = typeof w !== 'undefined' && !!w && w.CLOSING === 2;\n    if (!is) {\n        console.dir(w);\n        throw new Error('websocket not valid');\n    }\n}\n\n/**\n * Reuse the same socket even when multiple\n * collection replicate with the same server at once.\n */\nexport const WEBSOCKET_BY_CACHE_KEY: Map<string, WebsocketWithRefCount> = new Map();\nexport async function getWebSocket(\n    url: string,\n    /**\n     * The value of RxDatabase.token.\n     */\n    databaseToken: string\n): Promise<WebsocketWithRefCount> {\n    /**\n     * Also use the database token as cache-key\n     * to make it easier to test and debug\n     * multi-instance setups.\n     */\n    const cacheKey = url + '|||' + databaseToken;\n\n\n    const has = getFromMapOrCreate(\n        WEBSOCKET_BY_CACHE_KEY,\n        cacheKey,\n        () => {\n            ensureIsWebsocket(IsomorphicWebSocket);\n            const wsClient = new ReconnectingWebSocket(\n                url,\n                [],\n                {\n                    WebSocket: IsomorphicWebSocket\n                }\n            );\n\n            const connected$ = new BehaviorSubject<boolean>(false);\n            const openPromise = new Promise<void>(res => {\n                wsClient.onopen = () => {\n                    connected$.next(true);\n                    res();\n                };\n            });\n            wsClient.onclose = () => {\n                connected$.next(false);\n            };\n\n            const message$ = new Subject<any>();\n            wsClient.onmessage = (messageObj) => {\n                const message = JSON.parse(messageObj.data);\n                message$.next(message);\n            };\n\n            const error$ = new Subject<any>();\n            wsClient.onerror = (err) => {\n                const emitError = newRxError('RC_STREAM', {\n                    errors: toArray(err).map((er: any) => errorToPlainJson(er)),\n                    direction: 'pull'\n                });\n                error$.next(emitError);\n            };\n\n\n            return {\n                url,\n                socket: wsClient,\n                openPromise,\n                refCount: 1,\n                connected$,\n                message$,\n                error$\n            };\n        },\n        (value) => {\n            value.refCount = value.refCount + 1;\n        }\n    );\n    await has.openPromise;\n    return has;\n}\n\nexport function removeWebSocketRef(\n    url: string,\n    database: RxDatabase\n) {\n    const cacheKey = url + '|||' + database.token;\n    const obj = getFromMapOrThrow(WEBSOCKET_BY_CACHE_KEY, cacheKey);\n    obj.refCount = obj.refCount - 1;\n    if (obj.refCount === 0) {\n        WEBSOCKET_BY_CACHE_KEY.delete(cacheKey);\n        obj.connected$.complete();\n        obj.socket.close();\n    }\n}\n\n\n\nexport async function replicateWithWebsocketServer<RxDocType, CheckpointType>(\n    options: WebsocketClientOptions<RxDocType>\n): Promise<RxReplicationState<RxDocType, CheckpointType>> {\n    const socketState = await getWebSocket(options.url, options.collection.database.token);\n    const wsClient = socketState.socket;\n\n    const messages$ = socketState.message$;\n\n    let requestCounter = 0;\n    const requestFlag = randomCouchString(10);\n    function getRequestId() {\n        const count = requestCounter++;\n        return options.collection.database.token + '|' + requestFlag + '|' + count;\n    }\n    const replicationState = replicateRxCollection<RxDocType, CheckpointType>({\n        collection: options.collection,\n        replicationIdentifier: 'websocket-' + options.url,\n        live: options.live,\n        pull: {\n            batchSize: options.batchSize,\n            stream$: messages$.pipe(\n                filter(msg => msg.id === 'stream' && msg.collection === options.collection.name),\n                map(msg => msg.result)\n            ),\n            async handler(lastPulledCheckpoint: CheckpointType, batchSize: number) {\n                const requestId = getRequestId();\n                const request: WebsocketMessageType = {\n                    id: requestId,\n                    collection: options.collection.name,\n                    method: 'masterChangesSince',\n                    params: [lastPulledCheckpoint, batchSize]\n                };\n                wsClient.send(JSON.stringify(request));\n                const result = await firstValueFrom(\n                    messages$.pipe(\n                        filter(msg => msg.id === requestId),\n                        map(msg => msg.result)\n                    )\n                );\n                return result;\n            }\n        },\n        push: {\n            batchSize: options.batchSize,\n            handler(docs: RxReplicationWriteToMasterRow<RxDocType>[]) {\n                const requestId = getRequestId();\n                const request: WebsocketMessageType = {\n                    id: requestId,\n                    collection: options.collection.name,\n                    method: 'masterWrite',\n                    params: [docs]\n                };\n                wsClient.send(JSON.stringify(request));\n                return firstValueFrom(\n                    messages$.pipe(\n                        filter(msg => msg.id === requestId),\n                        map(msg => msg.result)\n                    )\n                );\n            }\n        }\n    });\n\n    socketState.error$.subscribe(err => replicationState.subjects.error.next(err));\n\n    socketState.connected$.subscribe(isConnected => {\n        if (isConnected) {\n            /**\n             * When the client goes offline and online again,\n             * we have to send a 'RESYNC' signal because the client\n             * might have missed out events while being offline.\n             */\n            replicationState.reSync();\n\n            /**\n             * Because reconnecting creates a new websocket-instance,\n             * we have to start the changestream from the remote again\n             * each time.\n             */\n            const streamRequest: WebsocketMessageType = {\n                id: 'stream',\n                collection: options.collection.name,\n                method: 'masterChangeStream$',\n                params: []\n            };\n            wsClient.send(JSON.stringify(streamRequest));\n        }\n    });\n\n    options.collection.onDestroy.push(() => removeWebSocketRef(options.url, options.collection.database));\n    return replicationState;\n}\n"],"mappings":"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"}