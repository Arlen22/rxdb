{"version":3,"file":"rx-storage-instance-mongodb.js","names":["BehaviorSubject","Subject","filter","firstValueFrom","getPrimaryFieldOfPrimaryKey","ensureNotFalsy","getFromMapOrThrow","getFromObjectOrThrow","isMaybeReadonlyArray","lastOfArray","now","requestIdlePromise","RX_META_LWT_MINIMUM","MongoClient","categorizeBulkWriteRows","MONGO_ID_SUBSTITUTE_FIELDNAME","getMongoDBIndexName","swapMongoToRxDoc","swapRxDocToMongo","RxStorageInstanceMongoDB","storage","databaseName","collectionName","schema","internals","options","settings","closed","changes$","runningOperations","runningWrites","mongoObjectIdCache","WeakMap","attachments","Error","primaryPath","primaryKey","inMongoPrimaryPath","mongoClient","databaseSettings","connection","mongoDatabase","db","version","indexes","slice","map","index","arIndex","push","mongoCollectionPromise","createCollection","then","mongoCollection","createIndexes","mongoIndex","forEach","field","name","key","_proto","prototype","bulkWrite","documentWrites","context","next","getValue","pipe","c","Promise","reject","ret","success","error","docIds","d","document","documentStates","findDocumentsById","categorized","errors","eventBulk","events","all","bulkInsertDocs","writeRow","docId","writeResult","findOneAndUpdate","$setOnInsert","upsert","includeResultMetadata","value","conflictError","status","documentId","documentInDb","isError","event","changeByDocId","get","bulkUpdateDocs","findOneAndReplace","_rev","previous","currentDocState","currentDoc","length","lastState","newestRow","checkpoint","id","lwt","_meta","withDeleted","session","plainQuery","$in","_deleted","result","queryResult","find","toArray","row","query","preparedQuery","mongoSelector","skip","limit","sort","mongoSort","resultDocs","documents","count","countDocuments","mode","getChangedDocumentsSince","sinceLwt","$or","$gt","$eq","lastDoc","cleanup","minimumDeletedTime","maxDeletionTime","deleteMany","$lt","getAttachmentData","_documentId","_attachmentId","_digest","changeStream","remove","drop","close","conflictResultionTasks","resolveConflictResultionTask","_taskSolution","createMongoDBStorageInstance","params","instance","resolve"],"sources":["../../../../src/plugins/storage-mongodb/rx-storage-instance-mongodb.ts"],"sourcesContent":["import {\n    BehaviorSubject,\n    Observable,\n    Subject,\n    filter,\n    firstValueFrom\n} from 'rxjs';\nimport { getPrimaryFieldOfPrimaryKey } from '../../rx-schema-helper';\nimport type {\n    BulkWriteRow,\n    ById,\n    EventBulk,\n    RxConflictResultionTask,\n    RxConflictResultionTaskSolution,\n    RxDocumentData,\n    RxDocumentDataById,\n    RxJsonSchema,\n    RxStorageBulkWriteResponse,\n    RxStorageChangeEvent,\n    RxStorageCountResult,\n    RxStorageDefaultCheckpoint,\n    RxStorageInstance,\n    RxStorageInstanceCreationParams,\n    RxStorageQueryResult,\n    RxStorageWriteErrorConflict,\n    StringKeys\n} from '../../types';\nimport {\n    ensureNotFalsy,\n    getFromMapOrThrow,\n    getFromObjectOrThrow,\n    isMaybeReadonlyArray,\n    lastOfArray,\n    now,\n    requestIdlePromise,\n    RX_META_LWT_MINIMUM\n} from '../../plugins/utils';\nimport {\n    MongoDBPreparedQuery,\n    MongoDBStorageInternals,\n    MongoQuerySelector,\n    RxStorageMongoDBInstanceCreationOptions,\n    RxStorageMongoDBSettings\n} from './mongodb-types';\nimport { RxStorageMongoDB } from './rx-storage-mongodb';\nimport {\n    Db as MongoDatabase,\n    Collection as MongoCollection,\n    MongoClient,\n    ObjectId,\n    ClientSession\n} from 'mongodb';\nimport { categorizeBulkWriteRows } from '../../rx-storage-helper';\nimport {\n    MONGO_ID_SUBSTITUTE_FIELDNAME,\n    getMongoDBIndexName,\n    swapMongoToRxDoc,\n    swapRxDocToMongo\n} from './mongodb-helper';\n\nexport class RxStorageInstanceMongoDB<RxDocType> implements RxStorageInstance<\n    RxDocType,\n    MongoDBStorageInternals,\n    RxStorageMongoDBInstanceCreationOptions,\n    RxStorageDefaultCheckpoint\n> {\n\n    public readonly primaryPath: StringKeys<RxDocumentData<RxDocType>>;\n    public readonly inMongoPrimaryPath: string;\n    public closed = false;\n    private readonly changes$: Subject<EventBulk<RxStorageChangeEvent<RxDocumentData<RxDocType>>, RxStorageDefaultCheckpoint>> = new Subject();\n    public readonly mongoClient: MongoClient;\n    public readonly mongoDatabase: MongoDatabase;\n    public readonly mongoCollectionPromise: Promise<MongoCollection<RxDocumentData<RxDocType> | any>>;\n    // public mongoChangeStream?: MongoChangeStream<any, ChangeStreamDocument<any>>;\n\n\n    /**\n     * Closing the connection must not happen when\n     * an operation is running, otherwise we get an error.\n     * So we store all running operations here so that\n     * they can be awaited.\n     */\n    public readonly runningOperations = new BehaviorSubject(0);\n    public readonly runningWrites = new BehaviorSubject(0);\n\n    /**\n     * We use this to be able to still fetch\n     * the objectId after transforming the document from mongo-style (with _id)\n     * to RxDB\n     */\n    public readonly mongoObjectIdCache = new WeakMap<RxDocumentData<RxDocType>, ObjectId>();\n\n    constructor(\n        public readonly storage: RxStorageMongoDB,\n        public readonly databaseName: string,\n        public readonly collectionName: string,\n        public readonly schema: Readonly<RxJsonSchema<RxDocumentData<RxDocType>>>,\n        public readonly internals: MongoDBStorageInternals,\n        public readonly options: Readonly<RxStorageMongoDBInstanceCreationOptions>,\n        public readonly settings: RxStorageMongoDBSettings\n    ) {\n        if (this.schema.attachments) {\n            throw new Error('attachments not supported in mongodb storage, make a PR if you need that');\n        }\n        this.primaryPath = getPrimaryFieldOfPrimaryKey(this.schema.primaryKey);\n        this.inMongoPrimaryPath = this.primaryPath === '_id' ? MONGO_ID_SUBSTITUTE_FIELDNAME : this.primaryPath;\n        this.mongoClient = new MongoClient(storage.databaseSettings.connection);\n        this.mongoDatabase = this.mongoClient.db(databaseName + '-v' + this.schema.version);\n\n        const indexes = (this.schema.indexes ? this.schema.indexes.slice() : []).map(index => {\n            const arIndex = isMaybeReadonlyArray(index) ? index.slice(0) : [index];\n            return arIndex;\n        });\n        indexes.push([this.inMongoPrimaryPath]);\n\n        this.mongoCollectionPromise = this.mongoDatabase.createCollection(collectionName)\n            .then(async (mongoCollection) => {\n                await mongoCollection.createIndexes(\n                    indexes.map(index => {\n                        const mongoIndex: any = {};\n                        index.forEach(field => mongoIndex[field] = 1);\n                        return { name: getMongoDBIndexName(index), key: mongoIndex };\n                    })\n                );\n\n                /**\n                 * TODO in a setup where multiple servers run node.js\n                 * processes that use the mongodb storage, we should propagate\n                 * events by listening to the mongodb changestream.\n                 * This maybe should be a premium feature.\n                 */\n                // this.mongoChangeStream = mongoCollection.watch(\n                //     undefined, {\n                //     batchSize: 100\n                // }\n                // ).on('change', change => {\n\n\n                //     const eventBulkId = randomCouchString(10);\n                //     const newDocData: RxDocumentData<RxDocType> = (change as any).fullDocument;\n                //     const documentId = newDocData[this.primaryPath] as any;\n\n                //     const eventBulk: EventBulk<RxStorageChangeEvent<RxDocumentData<RxDocType>>, RxStorageDefaultCheckpoint> = {\n                //         checkpoint: {\n                //             id: newDocData[this.primaryPath] as any,\n                //             lwt: newDocData._meta.lwt\n                //         },\n                //         context: 'mongodb-write',\n                //         id: eventBulkId,\n                //         events: [{\n                //             documentData: newDocData,\n                //             documentId,\n                //             eventId: randomCouchString(10),\n                //             operation: 'INSERT',\n                //             previousDocumentData: undefined,\n                //             startTime: now(),\n                //             endTime: now()\n                //         }]\n                //     };\n\n                //     this.changes$.next(eventBulk);\n                // });\n\n\n                return mongoCollection;\n            });\n\n\n    }\n\n    /**\n     * Bulk writes on the mongodb storage.\n     * Notice that MongoDB does not support cross-document transactions\n     * so we have to do a update-if-previous-is-correct like operations.\n     * (Similar to what RxDB does with the revision system)\n     */\n    async bulkWrite(\n        documentWrites: BulkWriteRow<RxDocType>[],\n        context: string\n    ): Promise<RxStorageBulkWriteResponse<RxDocType>> {\n        this.runningOperations.next(this.runningOperations.getValue() + 1);\n        await firstValueFrom(this.runningWrites.pipe(filter(c => c === 0)));\n        this.runningWrites.next(this.runningWrites.getValue() + 1);\n        const mongoCollection = await this.mongoCollectionPromise;\n        if (this.closed) {\n            return Promise.reject(new Error('already closed'));\n        }\n        const primaryPath = this.primaryPath;\n        const ret: RxStorageBulkWriteResponse<RxDocType> = {\n            success: {},\n            error: {}\n        };\n\n        const docIds = documentWrites.map(d => (d.document as any)[primaryPath]);\n        const documentStates = await this.findDocumentsById(\n            docIds,\n            true\n        );\n        const categorized = categorizeBulkWriteRows<RxDocType>(\n            this,\n            primaryPath as any,\n            documentStates,\n            documentWrites,\n            context\n        );\n        ret.error = categorized.errors;\n\n        /**\n         * Reset the event bulk because\n         * conflicts can still appear after the categorization\n         */\n        const eventBulk = categorized.eventBulk;\n        eventBulk.events = [];\n\n        await Promise.all([\n            /**\n             * Inserts\n             * @link https://sparkbyexamples.com/mongodb/mongodb-insert-if-not-exists/\n             */\n            Promise.all(\n                categorized.bulkInsertDocs.map(async (writeRow) => {\n                    const docId: string = writeRow.document[primaryPath] as any;\n                    const writeResult = await mongoCollection.findOneAndUpdate(\n                        {\n                            [this.inMongoPrimaryPath]: docId\n                        },\n                        {\n                            $setOnInsert: swapRxDocToMongo(writeRow.document)\n                        },\n                        {\n                            upsert: true,\n                            includeResultMetadata: true\n                        }\n                    );\n                    if (writeResult.value) {\n                        // had insert conflict\n                        const conflictError: RxStorageWriteErrorConflict<RxDocType> = {\n                            status: 409,\n                            documentId: docId,\n                            writeRow,\n                            documentInDb: swapMongoToRxDoc(writeResult.value),\n                            isError: true\n                        };\n                        ret.error[docId] = conflictError;\n                    } else {\n                        const event = categorized.changeByDocId.get(docId);\n                        if (event) {\n                            eventBulk.events.push(event);\n                        }\n                        ret.success[docId as any] = writeRow.document;\n                    }\n                })\n            ),\n            /**\n             * Updates\n             */\n            Promise.all(\n                categorized.bulkUpdateDocs.map(async (writeRow) => {\n                    const docId = writeRow.document[primaryPath] as string;\n                    const writeResult = await mongoCollection.findOneAndReplace(\n                        {\n                            [this.inMongoPrimaryPath]: docId,\n                            _rev: ensureNotFalsy(writeRow.previous)._rev\n                        },\n                        swapRxDocToMongo(writeRow.document),\n                        {\n                            includeResultMetadata: true,\n                            upsert: false\n                        }\n                    );\n                    if (!writeResult.value) {\n                        const currentDocState = await this.findDocumentsById([docId], true);\n                        const currentDoc = getFromObjectOrThrow(currentDocState, docId);\n                        // had insert conflict\n                        const conflictError: RxStorageWriteErrorConflict<RxDocType> = {\n                            status: 409,\n                            documentId: docId,\n                            writeRow,\n                            documentInDb: currentDoc,\n                            isError: true\n                        };\n                        ret.error[docId] = conflictError;\n                    } else {\n                        const event = getFromMapOrThrow(categorized.changeByDocId, docId);\n                        eventBulk.events.push(event);\n                        ret.success[docId as any] = writeRow.document;\n                    }\n\n                })\n            )\n        ]);\n\n        if (categorized.eventBulk.events.length > 0) {\n            const lastState = ensureNotFalsy(categorized.newestRow).document;\n            categorized.eventBulk.checkpoint = {\n                id: lastState[primaryPath],\n                lwt: lastState._meta.lwt\n            };\n            this.changes$.next(categorized.eventBulk);\n        }\n\n        this.runningWrites.next(this.runningWrites.getValue() - 1);\n        this.runningOperations.next(this.runningOperations.getValue() - 1);\n        return ret;\n    }\n\n    async findDocumentsById(\n        docIds: string[],\n        withDeleted: boolean,\n        session?: ClientSession\n    ): Promise<RxDocumentDataById<RxDocType>> {\n        this.runningOperations.next(this.runningOperations.getValue() + 1);\n        const mongoCollection = await this.mongoCollectionPromise;\n        const primaryPath = this.primaryPath;\n\n        const plainQuery: MongoQuerySelector<any> = {\n            [primaryPath]: {\n                $in: docIds\n            }\n        };\n        if (!withDeleted) {\n            plainQuery._deleted = false;\n        }\n        const result: ById<RxDocumentData<RxDocType>> = {};\n        const queryResult = await mongoCollection.find(\n            plainQuery,\n            {\n                session\n            }\n        ).toArray();\n        queryResult.forEach(row => {\n            result[(row as any)[primaryPath]] = swapMongoToRxDoc(\n                row as any\n            );\n        });\n        this.runningOperations.next(this.runningOperations.getValue() - 1);\n        return result;\n    }\n\n    async query(\n        preparedQuery: MongoDBPreparedQuery<RxDocType>\n    ): Promise<RxStorageQueryResult<RxDocType>> {\n        this.runningOperations.next(this.runningOperations.getValue() + 1);\n        const mongoCollection = await this.mongoCollectionPromise;\n\n        let query = mongoCollection.find(preparedQuery.mongoSelector);\n        if (preparedQuery.query.skip) {\n            query = query.skip(preparedQuery.query.skip);\n        }\n        if (preparedQuery.query.limit) {\n            query = query.limit(preparedQuery.query.limit);\n        }\n        if (preparedQuery.query.sort) {\n            query = query.sort(preparedQuery.mongoSort);\n        }\n        const resultDocs = await query.toArray();\n        this.runningOperations.next(this.runningOperations.getValue() - 1);\n        return {\n            documents: resultDocs.map(d => swapMongoToRxDoc(d))\n        };\n    }\n\n    async count(\n        preparedQuery: MongoDBPreparedQuery<RxDocType>\n    ): Promise<RxStorageCountResult> {\n        this.runningOperations.next(this.runningOperations.getValue() + 1);\n        const mongoCollection = await this.mongoCollectionPromise;\n        const count = await mongoCollection.countDocuments(preparedQuery.mongoSelector);\n        this.runningOperations.next(this.runningOperations.getValue() - 1);\n        return {\n            count,\n            mode: 'fast'\n        };\n    }\n\n    async getChangedDocumentsSince(\n        limit: number,\n        checkpoint?: RxStorageDefaultCheckpoint\n    ): Promise<{\n        documents: RxDocumentData<RxDocType>[];\n        checkpoint: RxStorageDefaultCheckpoint;\n    }> {\n        this.runningOperations.next(this.runningOperations.getValue() + 1);\n        const mongoCollection = await this.mongoCollectionPromise;\n        const sinceLwt = checkpoint ? checkpoint.lwt : RX_META_LWT_MINIMUM;\n        const plainQuery = {\n            $or: [\n                {\n                    '_meta.lwt': {\n                        $gt: sinceLwt\n                    }\n                },\n                {\n                    '_meta.lwt': {\n                        $eq: sinceLwt\n                    },\n                    [this.inMongoPrimaryPath]: {\n                        $gt: checkpoint ? checkpoint.id : ''\n                    }\n                }\n            ]\n        };\n        const query = mongoCollection.find(plainQuery)\n            .sort({\n                '_meta.lwt': 1,\n                [this.inMongoPrimaryPath]: 1\n            })\n            .limit(limit);\n        const documents = await query.toArray();\n        const lastDoc = lastOfArray(documents);\n        this.runningOperations.next(this.runningOperations.getValue() - 1);\n        return {\n            documents: documents.map(d => swapMongoToRxDoc(d)),\n            checkpoint: lastDoc ? {\n                id: lastDoc[this.primaryPath],\n                lwt: lastDoc._meta.lwt\n            } : checkpoint ? checkpoint : {\n                id: '',\n                lwt: 0\n            }\n        };\n    }\n\n    async cleanup(minimumDeletedTime: number): Promise<boolean> {\n        this.runningOperations.next(this.runningOperations.getValue() + 1);\n        const mongoCollection = await this.mongoCollectionPromise;\n        const maxDeletionTime = now() - minimumDeletedTime;\n        await mongoCollection.deleteMany({\n            _deleted: true,\n            '_meta.lwt': {\n                $lt: maxDeletionTime\n            }\n        });\n        this.runningOperations.next(this.runningOperations.getValue() - 1);\n        return true;\n    }\n\n    async getAttachmentData(\n        _documentId: string,\n        _attachmentId: string,\n        _digest: string\n    ): Promise<string> {\n        await this.mongoCollectionPromise;\n        throw new Error('attachments not implemented, make a PR');\n    }\n\n    changeStream(): Observable<EventBulk<RxStorageChangeEvent<RxDocumentData<RxDocType>>, RxStorageDefaultCheckpoint>> {\n        return this.changes$;\n    }\n\n    async remove(): Promise<void> {\n        this.runningOperations.next(this.runningOperations.getValue() + 1);\n        const mongoCollection = await this.mongoCollectionPromise;\n        await mongoCollection.drop();\n        this.runningOperations.next(this.runningOperations.getValue() - 1);\n        await this.close();\n    }\n\n    async close(): Promise<void> {\n        // TODO without this next-tick we have random fails in the tests\n        await requestIdlePromise(200);\n\n        if (this.closed) {\n            return Promise.reject(new Error('already closed'));\n        }\n        this.closed = true;\n        await this.mongoCollectionPromise;\n        await firstValueFrom(this.runningOperations.pipe(filter(c => c === 0)));\n        // await ensureNotFalsy(this.mongoChangeStream).close();\n        await this.mongoClient.close();\n    }\n\n    conflictResultionTasks(): Observable<RxConflictResultionTask<RxDocType>> {\n        return new Subject();\n    }\n    async resolveConflictResultionTask(_taskSolution: RxConflictResultionTaskSolution<RxDocType>): Promise<void> { }\n}\n\nexport function createMongoDBStorageInstance<RxDocType>(\n    storage: RxStorageMongoDB,\n    params: RxStorageInstanceCreationParams<RxDocType, RxStorageMongoDBInstanceCreationOptions>,\n    settings: RxStorageMongoDBSettings\n): Promise<RxStorageInstanceMongoDB<RxDocType>> {\n    const instance = new RxStorageInstanceMongoDB(\n        storage,\n        params.databaseName,\n        params.collectionName,\n        params.schema,\n        {},\n        params.options,\n        settings\n    );\n    return Promise.resolve(instance);\n}\n"],"mappings":"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"}