{"version":3,"file":"connection-handler-simple-peer.js","names":["_rxjs","require","_index","_simplePeer","_interopRequireDefault","_rxError","sendMessage","ws","msg","send","JSON","stringify","getConnectionHandlerSimplePeer","serverUrl","wrtc","creator","options","socket","WebSocket","connect$","Subject","disconnect$","message$","response$","error$","peers","Map","ownPeerId","onopen","onmessage","msgEvent","parse","data","type","yourPeerId","room","topic","otherPeerIds","forEach","remotePeerId","has","newPeer","Peer","initiator","trickle","set","on","signal","senderPeerId","receiverPeerId","messageOrResponse","toString","result","next","peer","response","message","error","console","log","dir","newRxError","getFromMapOrThrow","handler","destroy","close","complete","PROMISE_RESOLVE_VOID"],"sources":["../../../../src/plugins/replication-webrtc/connection-handler-simple-peer.ts"],"sourcesContent":["import { Subject } from 'rxjs';\nimport {\n    getFromMapOrThrow,\n    PROMISE_RESOLVE_VOID,\n    randomCouchString\n} from '../../plugins/utils/index.ts';\nimport type {\n    WebRTCConnectionHandler,\n    WebRTCConnectionHandlerCreator,\n    WebRTCMessage,\n    WebRTCPeer,\n    PeerWithMessage,\n    PeerWithResponse\n} from './webrtc-types.ts';\n\nimport {\n    Instance as SimplePeer,\n    default as Peer\n} from 'simple-peer';\nimport type { RxError, RxTypeError } from '../../types/index.d.ts';\nimport { newRxError } from '../../rx-error.ts';\n// import { WebSocket } from 'ws';\n\nexport type SimplePeerInitMessage = {\n    type: 'init';\n    yourPeerId: string;\n};\nexport type SimplePeerJoinMessage = {\n    type: 'join';\n    room: string;\n};\nexport type SimplePeerJoinedMessage = {\n    type: 'joined';\n    otherPeerIds: string[];\n};\nexport type SimplePeerSignalMessage = {\n    type: 'signal';\n    room: string;\n    senderPeerId: string;\n    receiverPeerId: string;\n    data: string;\n};\n\nexport type PeerMessage = SimplePeerInitMessage | SimplePeerJoinMessage | SimplePeerJoinedMessage | SimplePeerSignalMessage;\n\n\nfunction sendMessage(ws: WebSocket, msg: PeerMessage) {\n    ws.send(JSON.stringify(msg));\n}\n\n/**\n * Returns a connection handler that uses simple-peer and the signaling server.\n */\nexport function getConnectionHandlerSimplePeer(\n    serverUrl: string,\n    wrtc?: any\n): WebRTCConnectionHandlerCreator {\n    const creator: WebRTCConnectionHandlerCreator = async (options) => {\n        const socket = new WebSocket(serverUrl);\n\n        const connect$ = new Subject<WebRTCPeer>();\n        const disconnect$ = new Subject<WebRTCPeer>();\n        const message$ = new Subject<PeerWithMessage>();\n        const response$ = new Subject<PeerWithResponse>();\n        const error$ = new Subject<RxError | RxTypeError>();\n\n        const peers = new Map<string, SimplePeer>();\n\n        let ownPeerId: string;\n        socket.onopen = () => {\n            socket.onmessage = msgEvent => {\n                const msg: PeerMessage = JSON.parse(msgEvent.data);\n                switch (msg.type) {\n                    case 'init':\n                        ownPeerId = msg.yourPeerId;\n                        sendMessage(socket, {\n                            type: 'join',\n                            room: options.topic\n                        });\n                        break;\n                    case 'joined':\n                        /**\n                         * PeerId is created by the signaling server\n                         * to prevent spoofing it.\n                         */\n                        msg.otherPeerIds.forEach(remotePeerId => {\n                            if (\n                                remotePeerId === ownPeerId ||\n                                peers.has(remotePeerId)\n                            ) {\n                                return;\n                            }\n                            const newPeer: SimplePeer = new Peer({\n                                initiator: remotePeerId > ownPeerId,\n                                wrtc,\n                                trickle: true\n                            }) as any;\n                            peers.set(remotePeerId, newPeer);\n\n                            newPeer.on('signal', (signal: any) => {\n                                sendMessage(socket, {\n                                    type: 'signal',\n                                    senderPeerId: ownPeerId,\n                                    receiverPeerId: remotePeerId,\n                                    room: options.topic,\n                                    data: signal\n                                });\n                            });\n\n                            newPeer.on('data', (messageOrResponse: any) => {\n                                messageOrResponse = JSON.parse(messageOrResponse.toString());\n                                if (messageOrResponse.result) {\n                                    response$.next({\n                                        peer: newPeer as any,\n                                        response: messageOrResponse\n                                    });\n                                } else {\n                                    message$.next({\n                                        peer: newPeer as any,\n                                        message: messageOrResponse\n                                    });\n                                }\n                            });\n\n                            newPeer.on('error', (error) => {\n                                console.log('CLIENT(' + ownPeerId + ') peer got error:');\n                                console.dir(error);\n                                error$.next(newRxError('RC_WEBRTC_PEER', {\n                                    error\n                                }));\n                            });\n\n                            newPeer.on('connect', () => {\n                                connect$.next(newPeer as any);\n                            });\n\n                        });\n                        break;\n                    case 'signal':\n                        // console.log('got signal(' + peerId + ') ' + data.from + ' -> ' + data.to);\n                        const peer = getFromMapOrThrow(peers, msg.senderPeerId);\n                        peer.signal(msg.data);\n                        break;\n                }\n            }\n        };\n\n        const handler: WebRTCConnectionHandler = {\n            error$,\n            connect$,\n            disconnect$,\n            message$,\n            response$,\n            async send(peer: WebRTCPeer, message: WebRTCMessage) {\n                await (peer as any).send(JSON.stringify(message));\n            },\n            destroy() {\n                socket.close();\n                error$.complete();\n                connect$.complete();\n                disconnect$.complete();\n                message$.complete();\n                response$.complete();\n                return PROMISE_RESOLVE_VOID;\n            }\n        };\n        return handler;\n    };\n    return creator;\n}\n"],"mappings":"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"}