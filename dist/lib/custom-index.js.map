{"version":3,"file":"custom-index.js","names":["_rxSchemaHelper","require","_utils","_queryPlanner","getIndexMeta","schema","index","fieldNameProperties","map","fieldName","schemaPart","getSchemaByObjectPath","Error","type","parsedLengths","getStringLengthOfIndexNumber","hasComplexPath","includes","getValueFn","objectPathMonad","getIndexableStringMonad","ret","docData","str","i","length","props","fieldValue","padEnd","maxLength","boolToStr","getNumberIndexString","minimum","Math","floor","maximum","ceil","multipleOf","valueSpan","nonDecimals","toString","multipleOfParts","split","decimals","roundedMinimum","getIndexStringLength","forEach","getPrimaryKeyFromIndexableString","indexableString","primaryKeyLength","paddedPrimaryKey","slice","primaryKey","trimEnd","nonDecimalsValueAsString","padStart","splitByDecimalPoint","decimalValueAsString","getStartIndexStringFromLowerBound","lowerBound","inclusiveStart","idx","bound","ensureNotFalsy","INDEX_MAX","INDEX_MIN","fillChar","repeat","getStartIndexStringFromUpperBound","upperBound","inclusiveEnd"],"sources":["../../src/custom-index.ts"],"sourcesContent":["/**\n * For some RxStorage implementations,\n * we need to use our custom crafted indexes\n * so we can easily iterate over them. And sort plain arrays of document data.\n */\n\nimport { getSchemaByObjectPath } from './rx-schema-helper';\nimport type {\n    JsonSchema,\n    RxDocumentData,\n    RxJsonSchema\n} from './types';\nimport {\n    ensureNotFalsy,\n    objectPathMonad,\n    ObjectPathMonadFunction\n} from './plugins/utils';\nimport { INDEX_MAX, INDEX_MIN } from './query-planner';\n\n\nexport function getIndexMeta<RxDocType>(\n    schema: RxJsonSchema<RxDocumentData<RxDocType>>,\n    index: string[]\n) {\n    /**\n     * Prepare all relevant information\n     * outside of the returned function\n     * to save performance when the returned\n     * function is called many times.\n     */\n    const fieldNameProperties: {\n        fieldName: string;\n        schemaPart: JsonSchema;\n        /*\n         * Only in number fields.\n         */\n        parsedLengths?: ParsedLengths;\n        getValueFn: ObjectPathMonadFunction<RxDocType>;\n    }[] = index.map(fieldName => {\n        const schemaPart = getSchemaByObjectPath(\n            schema,\n            fieldName\n        );\n        if (!schemaPart) {\n            throw new Error('not in schema: ' + fieldName);\n        }\n        const type = schemaPart.type;\n        let parsedLengths: ParsedLengths | undefined;\n        if (type === 'number' || type === 'integer') {\n            parsedLengths = getStringLengthOfIndexNumber(\n                schemaPart\n            );\n        }\n\n        return {\n            fieldName,\n            schemaPart,\n            parsedLengths,\n            hasComplexPath: fieldName.includes('.'),\n            getValueFn: objectPathMonad(fieldName)\n        };\n    });\n    return fieldNameProperties;\n}\n\n\n/**\n * Crafts an indexable string that can be used\n * to check if a document would be sorted below or above\n * another documents, dependent on the index values.\n * @monad for better performance\n *\n * IMPORTANT: Performance is really important here\n * which is why we code so 'strange'.\n * Always run performance tests when you want to\n * change something in this method.\n */\nexport function getIndexableStringMonad<RxDocType>(\n    schema: RxJsonSchema<RxDocumentData<RxDocType>>,\n    index: string[]\n): (docData: RxDocumentData<RxDocType>) => string {\n    const fieldNameProperties = getIndexMeta(schema, index);\n\n    /**\n     * @hotPath Performance of this function is very critical!\n     */\n    const ret = function (docData: RxDocumentData<RxDocType>): string {\n        let str = '';\n        for (let i = 0; i < fieldNameProperties.length; ++i) {\n            const props = fieldNameProperties[i];\n            const schemaPart = props.schemaPart;\n            const type = schemaPart.type;\n            let fieldValue = props.getValueFn(docData);\n            if (type === 'string') {\n                // is string\n                if (!fieldValue) {\n                    fieldValue = '';\n                }\n                str += fieldValue.padEnd(schemaPart.maxLength as number, ' ');\n            } else if (type === 'boolean') {\n                // is boolean\n                const boolToStr = fieldValue ? '1' : '0';\n                str += boolToStr;\n            } else {\n                // is number\n                const parsedLengths = props.parsedLengths as ParsedLengths;\n                if (!fieldValue) {\n                    fieldValue = 0;\n                }\n                str += getNumberIndexString(\n                    parsedLengths,\n                    fieldValue\n                );\n            }\n        }\n        return str;\n    };\n    return ret;\n}\n\ndeclare type ParsedLengths = {\n    nonDecimals: number;\n    decimals: number;\n    roundedMinimum: number;\n};\nexport function getStringLengthOfIndexNumber(\n    schemaPart: JsonSchema\n): ParsedLengths {\n    const minimum = Math.floor(schemaPart.minimum as number);\n    const maximum = Math.ceil(schemaPart.maximum as number);\n    const multipleOf: number = schemaPart.multipleOf as number;\n\n    const valueSpan = maximum - minimum;\n    const nonDecimals = valueSpan.toString().length;\n\n    const multipleOfParts = multipleOf.toString().split('.');\n    let decimals = 0;\n    if (multipleOfParts.length > 1) {\n        decimals = multipleOfParts[1].length;\n    }\n    return {\n        nonDecimals,\n        decimals,\n        roundedMinimum: minimum\n    };\n}\n\nexport function getIndexStringLength<RxDocType>(\n    schema: RxJsonSchema<RxDocumentData<RxDocType>>,\n    index: string[]\n): number {\n    const fieldNameProperties = getIndexMeta(schema, index);\n    let length = 0;\n    fieldNameProperties.forEach(props => {\n        const schemaPart = props.schemaPart;\n        const type = schemaPart.type;\n\n        if (type === 'string') {\n            length += schemaPart.maxLength as number;\n        } else if (type === 'boolean') {\n            length += 1;\n        } else {\n            const parsedLengths = props.parsedLengths as ParsedLengths;\n            length = length + parsedLengths.nonDecimals + parsedLengths.decimals;\n        }\n\n    });\n    return length;\n}\n\n\nexport function getPrimaryKeyFromIndexableString(\n    indexableString: string,\n    primaryKeyLength: number\n): string {\n    const paddedPrimaryKey = indexableString.slice(primaryKeyLength * -1);\n    const primaryKey = paddedPrimaryKey.trimEnd();\n    return primaryKey;\n}\n\n\nexport function getNumberIndexString(\n    parsedLengths: ParsedLengths,\n    fieldValue: number\n): string {\n    let str: string = '';\n    const nonDecimalsValueAsString = (Math.floor(fieldValue) - parsedLengths.roundedMinimum).toString();\n    str += nonDecimalsValueAsString.padStart(parsedLengths.nonDecimals, '0');\n\n    const splitByDecimalPoint = fieldValue.toString().split('.');\n    const decimalValueAsString = splitByDecimalPoint.length > 1 ? splitByDecimalPoint[1] : '0';\n\n    str += decimalValueAsString.padEnd(parsedLengths.decimals, '0');\n    return str;\n}\n\nexport function getStartIndexStringFromLowerBound(\n    schema: RxJsonSchema<any>,\n    index: string[],\n    lowerBound: (string | boolean | number | null | undefined)[],\n    inclusiveStart: boolean\n): string {\n    let str = '';\n    index.forEach((fieldName, idx) => {\n        const schemaPart = getSchemaByObjectPath(\n            schema,\n            fieldName\n        );\n        const bound = lowerBound[idx];\n        const type = schemaPart.type;\n\n        switch (type) {\n            case 'string':\n                const maxLength = ensureNotFalsy(schemaPart.maxLength);\n                if (typeof bound === 'string') {\n                    str += (bound as string).padEnd(maxLength, ' ');\n                } else {\n                    // str += ''.padStart(maxLength, inclusiveStart ? ' ' : INDEX_MAX);\n                    str += ''.padEnd(maxLength, ' ');\n                }\n                break;\n            case 'boolean':\n                if (bound === null) {\n                    str += inclusiveStart ? '0' : INDEX_MAX;\n                } else {\n                    const boolToStr = bound ? '1' : '0';\n                    str += boolToStr;\n                }\n                break;\n            case 'number':\n            case 'integer':\n                const parsedLengths = getStringLengthOfIndexNumber(\n                    schemaPart\n                );\n                if (bound === null || bound === INDEX_MIN) {\n                    const fillChar = inclusiveStart ? '0' : INDEX_MAX;\n                    str += fillChar.repeat(parsedLengths.nonDecimals + parsedLengths.decimals);\n                } else {\n                    str += getNumberIndexString(\n                        parsedLengths,\n                        bound as number\n                    );\n                }\n                break;\n            default:\n                throw new Error('unknown index type ' + type);\n        }\n    });\n    return str;\n}\n\n\nexport function getStartIndexStringFromUpperBound(\n    schema: RxJsonSchema<any>,\n    index: string[],\n    upperBound: (string | boolean | number | null | undefined)[],\n    inclusiveEnd: boolean\n): string {\n    let str = '';\n    index.forEach((fieldName, idx) => {\n        const schemaPart = getSchemaByObjectPath(\n            schema,\n            fieldName\n        );\n        const bound = upperBound[idx];\n        const type = schemaPart.type;\n\n        switch (type) {\n            case 'string':\n                const maxLength = ensureNotFalsy(schemaPart.maxLength);\n                if (typeof bound === 'string') {\n                    str += (bound as string).padEnd(maxLength, inclusiveEnd ? INDEX_MAX : ' ');\n                } else {\n                    str += ''.padEnd(maxLength, inclusiveEnd ? INDEX_MAX : ' ');\n                }\n                break;\n            case 'boolean':\n                if (bound === null) {\n                    str += inclusiveEnd ? '0' : '1';\n                } else {\n                    const boolToStr = bound ? '1' : '0';\n                    str += boolToStr;\n                }\n                break;\n            case 'number':\n            case 'integer':\n                const parsedLengths = getStringLengthOfIndexNumber(\n                    schemaPart\n                );\n                if (bound === null || bound === INDEX_MAX) {\n                    const fillChar = inclusiveEnd ? '9' : '0';\n                    str += fillChar.repeat(parsedLengths.nonDecimals + parsedLengths.decimals);\n                } else {\n                    str += getNumberIndexString(\n                        parsedLengths,\n                        bound as number\n                    );\n                }\n                break;\n            default:\n                throw new Error('unknown index type ' + type);\n        }\n    });\n    return str;\n}\n"],"mappings":"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"}